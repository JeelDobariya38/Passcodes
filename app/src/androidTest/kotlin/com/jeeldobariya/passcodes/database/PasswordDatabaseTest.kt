package com.jeeldobariya.passcodes.database

import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.io.IOException

/**
 * Instrumented test for the Room database, specifically testing the PasswordsDao.
 * This test runs on an Android device/emulator.
 */
@RunWith(AndroidJUnit4::class) // Specifies the JUnit runner for Android instrumented tests
class PasswordDatabaseTest {

    private lateinit var passwordsDao: PasswordsDao
    private lateinit var db: MasterDatabase

    // This function runs before each test method
    @Before
    fun createDb() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        // Build an in-memory database for testing.
        // In-memory database ensures that tests are isolated and don't
        // interfere with the actual app database or other tests.
        db = Room.inMemoryDatabaseBuilder(
            context,
            MasterDatabase::class
        ).allowMainThreadQueries() // Allow queries on the main thread for simplicity in tests
            .build()
        passwordsDao = db.passwordsDao // Get the DAO instance
    }

    // This function runs after each test method
    @After
    @Throws(IOException::class) // Indicates that this method might throw an IOException
    fun closeDb() {
        db.close() // Close the database after each test to free resources
    }

    @Test
    fun insertAndGetAllPasswords_shouldReturnCorrectPasswords() = runTest {
        // Test: Insert multiple passwords and then retrieve all to verify
        val password1 = Password(domain = "example.com", username = "user1", password = "pass1", notes = "notes1")
        val password2 = Password(domain = "test.org", username = "user2", password = "pass2", notes = "notes2")

        passwordsDao.insertPassword(password1) // Insert the first password
        passwordsDao.insertPassword(password2) // Insert the second password

        // Collect the first emitted list from the Flow
        val allPasswords = passwordsDao.getAllPasswords().first()

        // Assertions using Google Truth
        assertThat(allPasswords).hasSize(2) // Check if two passwords were retrieved
        assertThat(allPasswords[0].domain).isEqualTo("test.org") // Assuming DESC order by ID
        assertThat(allPasswords[1].domain).isEqualTo("example.com")
        assertThat(allPasswords).containsExactly(password2.copy(id = 2), password1.copy(id = 1)).inOrder();
        // Note: The 'id' is auto-generated by Room, so we need to create copies with the expected IDs for comparison.
        // The order depends on your @Query("SELECT * FROM passwords ORDER BY id DESC")
    }

    @Test
    fun insertAndGetPasswordById_shouldReturnCorrectPassword() = runTest {
        // Test: Insert a password and retrieve it by its auto-generated ID
        val originalPassword = Password(domain = "domain.com", username = "user", password = "pass", notes = "some notes")
        val insertedId = passwordsDao.insertPassword(originalPassword) // Insert and get the generated ID

        // Retrieve the password using the inserted ID
        val retrievedPassword = passwordsDao.getPasswordById(insertedId.toInt())

        // Assertions
        assertThat(retrievedPassword).isNotNull() // Ensure a password was retrieved
        assertThat(retrievedPassword?.id).isEqualTo(insertedId.toInt()) // Check if the ID matches
        assertThat(retrievedPassword?.domain).isEqualTo(originalPassword.domain) // Check other properties
        assertThat(retrievedPassword?.username).isEqualTo(originalPassword.username)
        assertThat(retrievedPassword?.password).isEqualTo(originalPassword.password)
        assertThat(retrievedPassword?.notes).isEqualTo(originalPassword.notes)
    }

    @Test
    fun insertAndGetPasswordByUsernameAndDomain_shouldReturnCorrectPassword() = runTest {
        // Test: Insert a password and retrieve it by username and domain
        val targetUsername = "specific_user"
        val targetDomain = "specific_domain.net"
        val passwordToFind = Password(domain = targetDomain, username = targetUsername, password = "pwd", notes = "find me")
        val otherPassword = Password(domain = "other.net", username = "other", password = "xyz", notes = "not me")

        passwordsDao.insertPassword(otherPassword)
        passwordsDao.insertPassword(passwordToFind)

        // Retrieve the password by username and domain
        val retrievedPassword = passwordsDao.getPasswordByUsernameAndDomain(targetUsername, targetDomain)

        // Assertions
        assertThat(retrievedPassword).isNotNull()
        assertThat(retrievedPassword?.username).isEqualTo(targetUsername)
        assertThat(retrievedPassword?.domain).isEqualTo(targetDomain)
    }

    @Test
    fun updatePassword_shouldUpdateCorrectly() = runTest {
        // Test: Insert a password, update it, and verify the changes
        val originalPassword = Password(domain = "old.com", username = "old_user", password = "old_pass", notes = "old_notes")
        val insertedId = passwordsDao.insertPassword(originalPassword)

        // Create an updated password object (Room updates by primary key)
        val updatedPassword = originalPassword.copy(
            id = insertedId.toInt(), // Crucial: Set the ID of the existing row
            domain = "new.com",
            username = "new_user",
            password = "new_pass",
            notes = "new_notes"
        )
        val rowsAffected = passwordsDao.updatePassword(updatedPassword) // Perform the update

        // Assert that one row was affected
        assertThat(rowsAffected).isEqualTo(1)

        // Retrieve the password again and verify changes
        val retrievedPassword = passwordsDao.getPasswordById(insertedId.toInt())
        assertThat(retrievedPassword).isNotNull()
        assertThat(retrievedPassword?.domain).isEqualTo("new.com")
        assertThat(retrievedPassword?.username).isEqualTo("new_user")
        assertThat(retrievedPassword?.password).isEqualTo("new_pass")
        assertThat(retrievedPassword?.notes).isEqualTo("new_notes")
    }

    @Test
    fun deletePasswordById_shouldDeleteCorrectly() = runTest {
        // Test: Insert a password, delete it by ID, and verify its absence
        val passwordToDelete = Password(domain = "delete.me", username = "trash", password = "123", notes = "delete this")
        val insertedId = passwordsDao.insertPassword(passwordToDelete)

        // Delete the password by its ID
        val rowsDeleted = passwordsDao.deletePasswordById(insertedId.toInt())

        // Assert that one row was deleted
        assertThat(rowsDeleted).isEqualTo(1)

        // Try to retrieve the deleted password; it should be null
        val retrievedPassword = passwordsDao.getPasswordById(insertedId.toInt())
        assertThat(retrievedPassword).isNull()
    }

    @Test
    fun getAllPasswords_whenEmpty_shouldReturnEmptyList() = runTest {
        // Test: Verify that getAllPasswords returns an empty list when the database is empty
        val allPasswords = passwordsDao.getAllPasswords().first()
        assertThat(allPasswords).isEmpty() // Assert that the list is empty
    }
}
